{"meta":{"title":"三碗清风","subtitle":"人如果没有梦想，那和无忧无虑有什么区别？","description":"","author":"梁任炽","url":"http://example.com","root":"/"},"pages":[{"title":"about","date":"2023-06-01T16:08:53.000Z","updated":"2023-06-01T16:08:53.769Z","comments":true,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":""}],"posts":[{"title":"无处不在的进程和线程","slug":"并发编程/无处不在的进程和线程","date":"2023-06-06T16:00:00.000Z","updated":"2023-06-07T11:54:42.763Z","comments":true,"path":"2023/06/07/并发编程/无处不在的进程和线程/","link":"","permalink":"http://example.com/2023/06/07/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E6%97%A0%E5%A4%84%E4%B8%8D%E5%9C%A8%E7%9A%84%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/","excerpt":"进程和线程是操作系统中两个容易混浠的概念，那什么是进程呢？简单来说进程就是程序的一次启动执行。","text":"进程和线程是操作系统中两个容易混浠的概念，那什么是进程呢？简单来说进程就是程序的一次启动执行。 程序是存放在硬盘中的可执行文件，主要包括代码指令和数据。一个进程是一个程序的一个启动和执行，是操作系统将程序装入内存，给程序分配必要的系统资源，并且开始运行程序的指令。同一个程序可以多次启动，对应多个进程。比如，多次打开Chrome浏览器程序。 进程的基本原理应用程序以进程的形式运行于操作系统之上，享受操作系统提供的服务。一个进程由程序段、数据段和进程控制块三部分组成。 现代操作系统中，进程是并发执行的，任何进程都可以同其他进程一起执行。在进程内部，代码段和数据段有自己的独立地址空间，不同进程的地址空间是相互隔离的。 对Java工程师来说，这里有一个问题：什么是Java程序的进程呢？ Java编写的程序都运行在Java虚拟机（JVM）中，每当使用Java命令启动一个Java应用程序时，就会启动一个JVM进程。在这个JVM进程内部，所有Java程序代码都以线程来运行的。JVM找到程序的入口点main()方法，然后运行main()方法，这样就产生了一个线程，这个线程称为主线程。当main()方法结束后，主线程运行完成，JVM进程也随即退出。 线程的基本原理进程是程序执行和系统进行并发调度的最小单位。为了充分发挥CPU的计算性能，提升CPU硬件资源的利用率，同时弥补进程调度过于笨重产生的问题，进程内部演进出了并发调度的诉求，于是发明了线程。 线程是指“进程代码段”的一次顺序执行流程。线程是CPU调度的最小单位。一个进程可以有一个或多个线程，各个线程之间共享进程的内存空间、系统资源，进程仍然是操作系统分配的最小单位。 一个标准的线程主要由三部分组成：线程基本信息、程序计数器、栈内存。 下面一段简单的代码，演示一个Java程序的线程信息： 1234567891011121314151617181920212223package com.crazymakercircle.multithread.basic.create;import com.crazymakercircle.util.Print;public class StackAreaDemo &#123; public static void main(String args[]) throws InterruptedException &#123; Print.cfo(&quot;当前线程名称：&quot;+Thread.currentThread().getName()); Print.cfo(&quot;当前线程ID：&quot;+Thread.currentThread().getId()); Print.cfo(&quot;当前线程状态：&quot;+Thread.currentThread().getState()); Print.cfo(&quot;当前线程优先级：&quot;+Thread.currentThread().getPriority()); int a = 1, b = 1; int c = a / b; anotherFun(); Thread.sleep(10000000); &#125; private static void anotherFun() &#123; int a = 1, b = 1; int c = a / b; anotherFun2(); &#125; private static void anotherFun2() &#123; int a = 1, b = 1; int c = a / b; &#125;&#125; 程序执行的结果如下： 1234[StackAreaDemo:main]:当前线程名称：main[StackAreaDemo:main]:当前线程ID：1[StackAreaDemo:main]:当前线程状态：RUNNABLE[StackAreaDemo:main]:当前线程优先级：5 该示例中定义了三个方法–main、anotherFun和anotherFun2，这三个方法有相同的三个局部变量a、b和c。整体的执行流程如下： 当执行到main()方法时，JVM为main分配了一个栈帧，保了三个局部变量，然后将栈帧压入main线程的栈内存。接着，main()方法还没有执行完，执行流程进入anotherFun()方法。 执行流程进入anotherFun()方法之前JVM为其分配对应的栈帧，保存其三个局部变量，然后压入main线程的栈内存。 执行流程进入anotherFun2()方法，老样子，JVM为anotherFun2()分配对应的栈帧，保存其三个局部变量，然后将帧压入main线程的栈内存。 进入anotherFun2()后，main线程含有三个帧，其栈结构如图所示 三个方法的栈帧弹出的过程与压入的过程刚好相反。anotherFun2()方法执行完成后，其栈帧从main线程的栈内存首先弹出，执行流程回到anotherFun()方法。anotherFun()方法执行完成后，其栈帧从main线程的栈内存弹出之后，执行流程回到main()方法。main()方法执行完成后，其栈帧弹出，此时main线程的栈内存已经全部弹空，没有剩余的栈帧。至此，main线程结束。正是由于栈帧（方法帧）的操作是后进先出的模式，这也是标准的栈操作模式，因此存放方法帧的内存也被叫作栈内存 进程与线程的区别下面总结一下进程与线程的区别，主要有以下几点： （1）线程是“进程代码段”的一次顺序执行流程。一个进程由一个或多个线程组成，一个进程至少有一个线程。 （2）线程是CPU调度的最小单位，进程是操作系统分配资源的最小单位。线程的划分尺度小于进程，使得多线程程序的并发性高。 （3）线程是出于高并发的调度诉求从进程内部演进而来的。线程的出现既充分发挥了CPU的计算性能，又弥补了进程调度过于笨重的问题。 （4）进程之间是相互独立的，但进程内部的各个线程之间并不完全独立。各个线程之间共享进程的方法区内存、堆内存、系统资源（文件句柄、系统信号等）。（5）切换速度不同：线程上下文切换比进程上下文切换要快得多。所以，有的时候，线程也称为轻量级进程","categories":[{"name":"并发编程","slug":"并发编程","permalink":"http://example.com/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"并发编程","slug":"并发编程","permalink":"http://example.com/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"}]},{"title":"知识体系构建计划","slug":"知识体系构建计划","date":"2023-06-06T15:00:00.000Z","updated":"2023-06-06T15:13:38.539Z","comments":true,"path":"2023/06/06/知识体系构建计划/","link":"","permalink":"http://example.com/2023/06/06/%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E6%9E%84%E5%BB%BA%E8%AE%A1%E5%88%92/","excerpt":"构建个人知识体系任务清单","text":"构建个人知识体系任务清单 并发编程知识体系一、多线程原理与实战 概述 创建线程的四种方式 线程的核心原理 线程的基本操作 线程池原理与实战 确定线程池的线程数 ThreadLocal原理与实战 二、确定线程池的线程数 线程安全问题 synchronized关键字 生产者-消费者问题 Java对象结构与内置锁 偏向锁的原理与实战 轻量级锁的原理与实战 重量级锁的原理与实战 偏向锁、轻量级锁与重量级锁的对比 线程间通信 三、CAS原理与JUC原子类 什么是CAS JUC原子类 对象操作的原子性 ABA问题 提升高并发场景下CAS操作的性能 CAS在JDK中的广泛应用 四、可见性与有序性的原理 CPU物理缓存结构 并发编程的三大问题 硬件层的MESI协议原理 有序性与内存屏障 JMM详解 Happens-Before规则 volatile不具备原子性 五、JUC显式锁的原理与实战 显式锁 悲观锁和乐观锁 公平锁与非公平锁 可中断锁与不可中断锁 共享锁与独占锁 读写锁 六、AQS抽象同步器的核心原理 锁与队列的关系 AQS的核心成员 AQS中的模板模式 通过AQS实现一把简单的独占锁 AQS锁抢占的原理 AQS的两个关键点：节点的入队和出队 AQS锁释放的原理 ReentrantLock的抢锁流程 AQS条件队列 AQS的实际应用 七、JUC容器类 线程安全的同步容器类 JUC高并发容器 CopyOnWriteArrayList BlockingQueue ConcurrentHashMap 八、高并发设计模式 线程安全的单例模式 Master-Worker模式 ForkJoin模式 生产者-消费者模式 Future模式 九、高并发核心模式之异步回调模式 从泡茶的案例讲起 join：异步阻塞之闷葫芦 FutureTask：异步调用之重武器 异步回调与主动调用 Guava的异步回调模式 Netty的异步回调模式 异步回调模式小结 十、CompletableFuture异步回调 CompletableFuture详解 异步任务的串行执行 异步任务的合并执行 异步任务的选择执行 CompletableFuture的综合案例 JVM知识体系一、自动内存管理机制 Java内存区域与内存溢出异常 垃圾收集器与内存分配策略 虚拟机性能监控与故障处理工具 调优案例分析与实战 二、虚拟机执行子系统 类文件结构 虚拟机类加载机制 虚拟机字节码执行引擎 类加载及执行子系统的案例与实战 三、程序编译与代码优化 早期（编译期）优化 晚期（运行期）优化 四、高效并发 Java内存模型与线程 线程安全与锁优化 MySQL知识体系Spring知识体系一、核心实现 容器的基本实现 默认标签的解析 自定义标签的解析 bean的加载 容器的功能扩展 AOP 二、企业应用 数据库连接JDBC 整合MyBatis 事务 SpringMVC 远程服务 Spring消息 SpringMVC知识体系一、创建Spring MVC之器 整体结构介绍 HttpServletBean FrameworkServlet DispatcherServlet 二、Spring MVC之用 HttpServletBean FrameworkServlet DispatcherServlet doDispatch结构 三、Spring MVC组件分析 组件概览 HandlerAdapter ViewResolver RequestToViewNameTranslator HandlerExceptionResolver MultipartResolver 四、总结与补充 总结 异步请求 Mybatis知识体系一、MyBatis常用工具类 使用SQL类生成语句 使用ScriptRunner执行脚本 使用SqlRunner操作数据库 MetaObject详解 MetaClass详解 ObjectFactory详解 ProxyFactory详解 二、MyBatis核心组件介绍 使用MyBatis操作数据库 MyBatis核心组件 Configuration详解 Executor详解 MappedStatement详解 StatementHandler详解 TypeHandler详解 ParameterHandler详解 ResultSetHandler详解 三、SqlSession的创建过程 XPath方式解析XML文件 Configuration实例创建过程 SqlSession实例创建过程 四、SqlSession执行Mapper过程 Mapper接口的注册过程 MappedStatement注册过程 Mapper方法调用过程详解 SqlSession执行Mapper过程 五、MyBatis缓存 MyBatis缓存的使用 MyBatis缓存实现类 MyBatis一级缓存实现原理 MyBatis二级缓存实现原理 MyBatis使用Redis缓存 六、MyBatis日志实现 Java日志体系 MyBatis日志实现 七、动态SQL实现原理 动态SQL的使用 SqlSource与BoundSql详解 LanguageDriver详解 SqlNode详解 动态SQL解析过程 从源码角度分析#{}和${}的区别 八、MyBatis插件原理及应用 MyBatis插件实现原理 自定义一个分页插件 自定义慢SQL统计插件 九、MyBatis级联映射与懒加载 MyBatis级联映射详解 MyBatis懒加载机制 MyBatis级联映射实现原理 懒加载实现原理 十、MyBatis Spring源码 MyBatis与Spring整合案例 MyBatis Spring的实现原理 Redis知识体系一、Redis多种数据类型使用场景 String数据类型的API和使用场景 String也能做，为什么还要用Hash 一种类型多种用法，原来List还可以这样做 开启Set数据类型的正确操作姿势 微服务的限流操作和Zset的那些瓜葛 二、数据结构底层 String数据结构底层解析 Hash数据结构底层解析 List数据结构底层解析 Set数据结构底层解析 Zset数据结构底层解析 三、数据持久化 RDB方式持久化 AOF方式持久化 AOF和RDB的数据恢复顺序 RDB和AOF持久化的优缺点 AOF+RDB混合模式配置 四、Redis的事务和Lua脚本操作 事务概述 事务使用 事务性质 Lua脚本 Lua实战 五、pub&#x2F;sub和Stream 频道的订阅与消息发送 发布与订阅的使用 发布与订阅的原理 订阅模式 pub和sub使用范例 与其他发布和订阅比较 Stream概述 Stream实例 六、主从复制 主从复制概述 主从复制工作原理 Redis复制的注意事项 搭建主从节点的实例 主从架构的“坑”和优化技巧 主从架构的作用 七、哨兵模式 哨兵架构概述 哨兵架构的搭建 Sentinel API 哨兵细节原理分析 客户端访问哨兵架构的系统 八、Redis集群 集群概述 集群作用 集群设计注意事项 Redis集群的搭建 数据分区策略 Redis一致性保证 节点通信机制 集群的其他细节 从节点的选举和提升 集群重新分片 扩容和缩容 故障转移和高可用 集群使用时的注意事项 九、Redis 6新特征 为什么Redis 6是多线程 开启多线程 Redis服务基准测试 ACL安全策略 十、布隆过滤器 布隆过滤器概述 环境安装 布隆过滤器的原理 应用场景 十一、Redis内存相关策略和内存碎片 maxmemory配置 数据淘汰策略 LRU算法 LFU算法 数据过期删除策略 主从架构和数据持久化对数据的过期处理 内存碎片 十二、分布式锁 为什么需要分布式锁 非阻塞锁的实现和原理 阻塞锁的实现和原理 Redlock原理 十三、高频面试题 缓存穿透 缓存击穿 缓存雪崩 设计模式知识体系 简单工作模式 策略模式 单一职责模式 开放-闭合原则 依赖倒转原则 装饰模式 代理模式 工厂方法模式 原型模式 模板方法模式 迪米特法则 外观模式 建造者模式 观察者模式 抽象工厂模式 状态模式 适配器模式 备忘录模式 组合模式 迭代器模式 单例模式 桥接模式 命令模式 职责链模式 中介者模式 享元模式 解释器模式 访问者模式 模式总结 RocketMQ知识体系一、RocketMQ路由中心NameServer NameServer架构设计 NameServer启动流程 NameServer路由注册、故障剔除 二、RocketMQ消息发送 漫谈RocketMQ消息发送 认识RocketMQ消息 生产者启动流程 消息发送基本流程 批量消息发送 三、RocketMQ消息存储 存储概要设计 初识消息存储 消息发送存储流程 存储文件组织与内存映射 RocketMQ存储文件 实时更新消息消费队列与索引文件 消息队列与索引文件恢复 文件刷盘机制 过期文件删除机制 四、RocketMQ消息消费 RocketMQ消息消费概述 消息消费者初探 消费者启动流程 消息拉取 消息队列负载与重新分布机制 消息消费过程 定时消息机制 消息过滤机制 顺序消息 五、消息过滤FilterServer ClassFilter运行机制 FilterServer注册剖析 类过滤模式订阅机制 消息拉取 六、RocketMQ主从同步(HA)机制 RocketMQ主从复制原理 RocketMQ读写分离机制 七、RocketMQ事务消息 事务消息实现思想 事务消息发送流程 事务消息提交或回滚 事务消息回查事务状态 八、RocketMQ实战 消息批量发送 消息发送队列自选择 消息过滤 事务消息 Spring整合RocketMQ Spring Cloud整合RocketMQ RocketMQ监控与运维命令 应用场景分析 数据结构知识体系 线性表 栈与队列 串 树 图 查找 排序","categories":[{"name":"计划","slug":"计划","permalink":"http://example.com/categories/%E8%AE%A1%E5%88%92/"}],"tags":[{"name":"计划","slug":"计划","permalink":"http://example.com/tags/%E8%AE%A1%E5%88%92/"}]},{"title":"世界在夏天变成一个巨大的熨斗","slug":"诗词/世界在夏天变成一个巨大的熨斗","date":"2023-06-05T16:00:00.000Z","updated":"2023-06-05T16:48:12.296Z","comments":true,"path":"2023/06/06/诗词/世界在夏天变成一个巨大的熨斗/","link":"","permalink":"http://example.com/2023/06/06/%E8%AF%97%E8%AF%8D/%E4%B8%96%E7%95%8C%E5%9C%A8%E5%A4%8F%E5%A4%A9%E5%8F%98%E6%88%90%E4%B8%80%E4%B8%AA%E5%B7%A8%E5%A4%A7%E7%9A%84%E7%86%A8%E6%96%97/","excerpt":"在一个没有暴雨的午后 你忽然得到启示 决定把皱巴巴的自己从抽屉里拿出来 你决定大胆信任这世界一次：","text":"在一个没有暴雨的午后 你忽然得到启示 决定把皱巴巴的自己从抽屉里拿出来 你决定大胆信任这世界一次： 高温、水汽与风，都一一准备好了 一个巨大的熨斗，正等着你 是的，你会因为 不再恐惧世界真实的温度 因为接受了那些命定的烫伤 而变得平整与妥帖 最后，世界抬起手，夏日走到尽头 而你第一次拥有了 自己的形状。","categories":[{"name":"诗词","slug":"诗词","permalink":"http://example.com/categories/%E8%AF%97%E8%AF%8D/"}],"tags":[{"name":"现代诗","slug":"现代诗","permalink":"http://example.com/tags/%E7%8E%B0%E4%BB%A3%E8%AF%97/"}]},{"title":"数据结构与算法学习-递归","slug":"数据结构/递归","date":"2023-06-02T16:00:00.000Z","updated":"2023-06-03T11:12:35.557Z","comments":true,"path":"2023/06/03/数据结构/递归/","link":"","permalink":"http://example.com/2023/06/03/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%80%92%E5%BD%92/","excerpt":"什么是递归递归是一个过程或函数直接或间接调用自身的一种方法，它可以把一个大型的问题层层转化为一个原问题相似、但规模较小的问题求解。递归实质上也是一种循环结构，它把“较复杂”情况的计算归结为“较简单”情况的计算，一直归结到“最简单”情况的计算为止。递归在概念上简化了问题，而不是因为它提高效率。","text":"什么是递归递归是一个过程或函数直接或间接调用自身的一种方法，它可以把一个大型的问题层层转化为一个原问题相似、但规模较小的问题求解。递归实质上也是一种循环结构，它把“较复杂”情况的计算归结为“较简单”情况的计算，一直归结到“最简单”情况的计算为止。递归在概念上简化了问题，而不是因为它提高效率。 递归调用的实现原理在数值计算领域可以采用递归计算，在非数值领域递归的应用也非常广泛。可以说，递归就是程序设计中的数学归纳法。 递归算法的构成应用递归应满足以下三个条件： 需要解决的问题可以转化成一个或多个子问题来求解，并且这些子问题的求解方法与原来的问题完全相同，只是数量规模上不同 递归调用的次数必须是有限的 必须有结束递归的条件（边界条件）来终止递归 一般递归算法的设计分成两步： 将规模较大的原问题分解为一个或多个规模较小的而又类似于原问题特性的子问题，即将较大的问题递归地用较小的子问题来描述，解决原问题的方法同样可以用来解决子问题。（递归的步骤） 确定一个或多个不需要分解、可直接求解的最小子问题。（最小子问题是递归的终结条件） 【例1】计算n!的递归方法 123456789public static int fact(int n)&#123; int temp; if (n==0)&#123; //递归终止的条件 return 1; &#125;else &#123; temp = n*fact1(n-1); //递归调用 &#125; return temp;&#125; 递归的方法只需少量的程序代码就可描述出解题过程所需要的多次重复计算，大大的减少程序的代码量。递归的能力就在于用有限的语句来定义对象的无限集合。 递归调用的内部过程递归函数的调用类似于多层函数的嵌套调用，只是调用单位和被调用单位是同一个函数而已。对于【例1】中求阶层的问题，假设程序运行时，n&#x3D;4，则程序的执行过程如下图所示： 递归调用的过程分成两个阶段： 递归过程：将原始问题不断转化为规模小了一级的新问题，从求4！变成求3！变成求2！，最终达到递归的终止条件，求1！ 回溯过程：从已知条件出发，沿递归的逆过程，逐一求值返回，直到递归初始处，完成递归调用 在这两个阶段中，系统会分别完成一系列的操作。在递归调用之前，系统需完成三项工作（使用栈完成操作）： 为被调用过程的局部变量分配存储区 将所有的实参、返回地址等信息传递给被调用过程保存 将控制转移到被调过程的入口 从被调用过程返回调用过程之前，系统也应完成三项工作： 保存被调过程的计算结果 释放被过程的数据区 依照被调过程保存的返回地址将控制转移到调用过程 递归的正确性证明可采用数学归纳法证明递归的正确性。 例如【例1】对于求阶层的递归函数fact(n)，可用归纳法证明如下： 【证明】当n&#x3D;0,fact(n)&#x3D;1 假设对于正整数n，fact(n)&#x3D;n!，试证明fact(n+1)&#x3D;(n+1)! fact(n+1) &#x3D;(n+1)*fact((n+1)-1) &#x3D;(n+1)*fact(n) &#x3D;(n+1)*n! &#x3D;(n+1)! 在以上归纳证明中，是对程序所操作的变量（正整数）进行归纳。然而，许多程序并没有明确可归纳的整数，因此在大多时候，需要对程序的递归结构进行归纳，这也是结构归纳法和一般数学归纳法的区别所在。 递归转化为非递归有些递归问题可以转化为非递归的方法实现，如伪递归可以用递推的方法实现。有些递归问题可以用回溯法解决。 递归转化为递推当递归算法涉及的数据定义形式是递归的情况下，通常可以将递归算法转化为递推算法，用递归的边界条件作为递推的边界条件，比如求阶层、斐波那契数列等。 递推也是一种从已知条件出发，用一种具体的算法，一步一步接近未知，一般釆用循环结构，经常和枚举配合使用。递推算法在求解的过程中，每一个中间变量都是已知的，而且没有重复计算，运算简捷，但是书写代码和理解代码比较难。 【例2】求阶乘的递推算法 1234567public static int fact2(int n)&#123; int s=1; for (int i=1;i&lt;=n;i++)&#123; s=s*i; &#125; return s;&#125; 【例3】斐波那契数列的递推算法 12345678910public static int fact3(int n)&#123; int f0=1,f1=1,f = 0; if (n&lt;2) return 1; for (int i=3;i&lt;=n;i++)&#123; f = f0+f1; f0=f1; f1=f; &#125; return f;&#125; 递归是从未知到已知，再从已知返回未知，利用子问题与父问题的关系，进而构造成有递归性的函数。 递推则与此相反，是从已知到未知，类似于一般解数学题的思路。 递归把问题简单化，抓的是问题与子问题的联系，而递推是从中间解推进，抓的是中间量与更靠近未知的中间量的联系，所以不能看成是互逆问题。 递归转化为回溯对于可以用回溯算法解决的问题，也可以用非递归的回溯来实现，如“八皇后问题” 回溯方法的步骤如下： 定义一个解空间，它包含问题的解 用适于搜索的方式组织该空间 用深度优先法搜索该空间，利用限界函数避免移动到不可能产生解的子空间 回溯算法的一个有趣的特性是在搜索执行的同时产生解空间。在搜索期间的任何时刻，仅保留从开始结点到当前节点的路径。因此，回溯算法的空间需求为O（从开始结点起最长路径的长度）。这个特性非常重要，因为解空间的大小通常是最长路径长度的指数或阶乘，所以如果要存储全部解空间的话，再多的空间也不够用。 【例4】回溯法求八皇后问题 实现思路： 我们先在棋盘的第0行第1个棋格放下第一个皇后 下一行寻找一个不冲突的棋格放下下一个皇后 循环第2步 如果到某一行全部8个格子都无法放下皇后，回溯到前一行，继续寻找下一个不冲突的棋格 把8个皇后都放在棋盘之后，输出或存储摆法，结束 定义棋盘 我们通过一个二维整型数组表示一个棋盘，数组内为1是放下了的皇后，0则是空白的棋格 我们下下面定义一个方法：通过检查棋格是否为1来知道是不是有皇后 12// 定义一个棋盘static int chessboard[][] = new int[8][8]; 检查冲突 这个方法用来检查冲突：在水平垂直方向、斜角上的棋格有无其他皇后，传入的（x,y）是需要检查的棋格，如检查棋格（1,0）即棋盘的第2行第1个，是否能放下皇后。 123456789101112// 检查是否符合规则private static boolean checked(int x,int y)&#123; for(int i = 0;i&lt;y;i++)&#123; // 检查水平垂直方向 if(chessboard[x][i]==1)return false; // 检测左斜角 if((x-y+i&gt;=0)&amp;&amp;chessboard[x-y+i][i]==1)return false; // 检查右斜角 if((x+y-i&lt;=7)&amp;&amp;chessboard[x+y-i][i]==1)return false; &#125; return true;&#125; 放下皇后 我们在每一行都执行以下步骤，通过从第1个棋格到第8个遍历寻找可以放下皇后的棋格，如果放下了皇后，我们就可以继续放下下一个了，将行数+1，我们递归调用这个方法 12345678910111213public static boolean solve(int y)&#123; // 将一行的8种情况都扫描一次 for(int i = 0;i&lt;8;i++)&#123; // 每次检测前都将当前行清空,避免脏数据 for(int k = 0;k&lt;8;k++)chessboard[k][y]=0; if(checked(i, y))&#123; chessboard[i][y] = 1; // 当前一行已经获得解法,进入下一行 solve(y+1); &#125; &#125; return false;&#125; 算法边界 当我们放下了所有8个皇后后，需要一个终止条件，我们在行数y&#x3D;8时，结束算法 1234// 当y=8时,已经找到一种解决方法if(y == 8)&#123; return true;&#125; 完整代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public class EightQueen&#123; // 定义一个棋盘 static int chessboard[][] = new int[8][8]; // 计数器 static int count = 0; // 解题方法 public static boolean solve(int y)&#123; // 当y=8时,已经找到一种解决方法,计数器加一并输入摆法 if(y == 8)&#123; System.out.println(&quot;solved!&quot;); show(); count++; return true; &#125; // 将一行的8种情况都扫描一次 for(int i = 0;i&lt;8;i++)&#123; // 每次检测前都将当前行清空,避免脏数据 for(int k = 0;k&lt;8;k++)chessboard[k][y]=0; if(checked(i, y))&#123; chessboard[i][y] = 1; // 当前一行已经获得解法,进入下一行 solve(y+1); &#125; &#125; return false; &#125; // 检查是否符合规则 private static boolean checked(int x,int y)&#123; for(int i = 0;i&lt;y;i++)&#123; // 检查垂直方向 if(chessboard[x][i]==1)return false; // 检测左斜角 if((x-y+i&gt;=0)&amp;&amp;chessboard[x-y+i][i]==1)return false; // 检查右斜角 if((x+y-i&lt;=7)&amp;&amp;chessboard[x+y-i][i]==1)return false; &#125; return true; &#125; // 输出棋盘摆法 public static void show()&#123; for(int i = 0;i&lt;8;i++)&#123; for(int j = 0;j&lt;8;j++)&#123; System.out.print(chessboard[j][i]+&quot; &quot;); &#125; System.out.println(&quot;&quot;); &#125; &#125;&#125;","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"垃圾收集器与内存分配策略","slug":"JVM/垃圾收集器与内存分配策略","date":"2023-04-17T16:00:00.000Z","updated":"2023-04-18T15:28:03.808Z","comments":true,"path":"2023/04/18/JVM/垃圾收集器与内存分配策略/","link":"","permalink":"http://example.com/2023/04/18/JVM/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/","excerpt":"垃圾收集器在对堆进行回收前，需要先识别出垃圾","text":"垃圾收集器在对堆进行回收前，需要先识别出垃圾 JVM如何识别垃圾引用计数算法算法思路：给对象添加一个引用计数器，每当有一个地方引用它时，计数器值就加1；当引用失效时，计算器值就减1；任何时刻计数器为0的对象就是不可能再被使用的。 优点：实现简单，判定效率高 缺点：难以解决对象之间相互循环引用的问题 对象objA和objB都有字段instance，赋值令objA.instance&#x3D;objB及objB.instance&#x3D;objA，除此之外，这两个对象再无任何引用，实际上这两个对象已经不可能再被访问，但是它们因为互相引用着对方，导致它们的引用计数都不为0，于是引用计数算法无法通知GC收集器回收它们。 可达性分析算法算法思路：通过一系列的称为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链（Reference Chain），当一个对象到GC Roots没有任何引用链相连（用图论的话来说，就是从GC Roots到这个对象不可达）时，则证明此对象是不可用的。 在Java中，可作为GC Roots的对象包括以下几种： 虚拟机栈中引用的对象 方法区中类静态属性引用的对象 方法区中常量引用的对象 本地方法栈JNI（即一般说的Native方法）引用的对象 引用无论是通过引用计数算法判断对象的引用数量，还是通过可达性分析算法判断对象的引用链是否可达，判定对象是否存活都与“引用”有关。 在JDK 1.2以前，Java中的引用的定义很传统：如果reference类型的数据中存储的数值代表的是另外一块内存的起始地址，就称这块内存代表着一个引用 JDK 1.2之后，Java对引用的概念进行了扩充，将引用分为强引用（Strong Reference）、软引用（Soft Reference）、弱引用（Weak Reference）、虚引用（Phantom Reference）4种，这4种引用强度依次逐渐减弱 强引用：我们平时 new 了一个对象就强引用，例如 Object obj &#x3D; new Object();即 使在内存不足✁情况下，JVM 宁愿抛出 OutOfMemory 错误也不会回收这种 对象 软引用：如果一个对象只具有软引用，则内存空间足够，垃圾回收器就不会回收它；如 果内存空间不足了，就会回收这些对象内存。 弱引用：具有弱引用对象拥有更短暂生命周期。在垃圾回收器线程扫描它所管辖 内存区域过程中，一旦发现了只具有弱引用对象，不管当前内存空间足够 与否，都会回收它内存。 虚引用：如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可 能被垃圾回收器回收。虚引用主要用来跟踪对象被垃圾回收器回收活动 回收方法区永久代的垃圾收集主要回收两部分内容：废弃常量和无用的类。 类需要满足以下3个条件才能算是“无用的类”： 该类所有的实例都已经被回收，也就是Java堆中不存在该类的任何实例。 加载该类的ClassLoader已经被回收。 该类对应的java.lang.Class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法 垃圾收集算法标记-清除算法算法思想：首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象 缺点： 效率问题，标记和清除两个过程的效率都不高 标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致以后在程序运行过程中需要分配较大对象时，无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作 复制算法算法思想：将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。 缺点：内存缩小为了原来的一半 标记-整理算法算法思想：标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。 分代收集算法 在 Java 中，堆被划分成两个不同的区域：新生代 ( Young )、老年代 ( Old )。而新生代 ( Young ) 又被划分为三个区域：Eden、From Survivor、To Survivor。这样划分的目的是为了使 JVM 能够 更好的管理堆内存中的对象，包括内存的分配以及回收。 新生代中一般保存新出现的对象，所以每次垃圾收集时都发现大批对象死去，只有少量对象存活， 便采用了 复制算法 ，只需要付出少量存活对象的复制成本就可以完成收集。 老年代中一般保存存活了很久的对象，他们存活率高、没有额外空间对它进行分配担保，就必须采 用 “标记-清理”或者“标记-整理” 算法。 永久代就是JVM的方法区。在这里都是放着一些被虚拟机加载的类信息，静态变量，常量等数据。 这个区中的东西比老年代和新生代更不容易回收 垃圾回收器如果说垃圾收集算法是内存回收的方法论，那么垃圾收集器就是内存回收的具体实现。下图展示了 7种作用于不同分代的收集器，其中用于回收新生代的收集器包括Serial、PraNew、Parallel Scavenge，回收老年代的收集器包括Serial Old、Parallel Old、CMS，还有用于回收整个Java堆 的G1收集器。不同收集器之间的连线表示它们可以搭配使用。 垃圾回收器 工作 区域 回收算法 工 作 线 程 用户 线程 并行 描述 Serial 新生代 复制算法 单线程 否 Client模式下默认新生代收集器。 简单高效 ParNew 新生代 复制算法 多 线 程 否 Serial的多线程版本，Server模式 下首选， 可搭配CMS的新生代收集 器 Parallel Scavenge 新生代 复制算法 多 线 程 否 目标是达到可控制的吞吐量 Serial Old 老年代 标记-整 理 单 线 程 否 Serial老年代版本，给Client模式下 的虚拟机使用 Parallel Old 老年代 标记-整 理 多 线 程 否 Parallel Scavenge老年代版本，吞 吐量优先 G1 新生代 + 老年代 标记-整 理 + 复 制算法 多 线 程 是 JDK1.9默认垃圾收集器 内存分配与回收策略 1、对象优先在新生代Eden区中分配。当Eden区没有足够空间进行分配时，虚拟机将发起一次minor gc 2、当 Eden 区空间满了， Java 虚拟机会触发一次 minor gc，以收集新生代 垃圾，存活下来对象，则会转移到 survivor 区 3、大对象（需要大量连续内存空间Java 对象，如那种很长字符串）直接进入老年代 4、如果对象在 Eden 出生，并经过第一次 Minor GC 后仍然存活，并且被 Survivor 容纳的话，年龄设为 1，每熬过一次 Minor GC，年龄+1，若年龄超过一定限制 （15），则被晋升到老年态。即长期存活的对象进入老年态。 5、老年代满了而无法容纳更多的对象，Minor GC 之后通常就会进行 Full GC， FullGC 清理整个内存堆 – 包括年轻代和年老代 6、Major GC 发生在老年代 GC，清理老年区，经常会伴随至少一次 Minor GC， 比 Minor GC 慢 10 倍以上 新生代GC（Minor GC）：指发生在新生代的垃圾收集动作，因为Java对象大多都具备朝生夕灭的特性，所以Minor GC非常频繁，一般回收速度也比较快。 老年代GC（Major GC &#x2F; Full GC）：指发生在老年代的GC，出现了Major GC，经常会伴随至少一次的Minor GC（但非绝对的，在Parallel Scavenge收集器的收集策略里就有直接进行Major GC的策略选择过程）。Major GC的速度一般会比Minor GC慢10倍以上。","categories":[{"name":"JVM","slug":"JVM","permalink":"http://example.com/categories/JVM/"}],"tags":[{"name":"jvm","slug":"jvm","permalink":"http://example.com/tags/jvm/"}]},{"title":"Java内存区域与内存溢出异常","slug":"JVM/Java内存区域与内存溢出异常","date":"2023-04-16T16:00:00.000Z","updated":"2023-04-17T15:28:38.711Z","comments":true,"path":"2023/04/17/JVM/Java内存区域与内存溢出异常/","link":"","permalink":"http://example.com/2023/04/17/JVM/Java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E4%B8%8E%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E5%BC%82%E5%B8%B8/","excerpt":"Java与C++之间有一堵由内存动态分配和垃圾收集技术所围成的“高墙”，墙外面的人想进去，墙里面的人却想出来。","text":"Java与C++之间有一堵由内存动态分配和垃圾收集技术所围成的“高墙”，墙外面的人想进去，墙里面的人却想出来。 JVM内存数据区域 程序计数器：当前线程所执行字节码行号指示器，用于记录正在执行虚拟机字节指令地址，线程私有。 Java虚拟机栈：存放基本数据类型、对象引用、方法出口等，线程私有。 如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常；如果虚拟机栈可以动态扩展（当前大部分的Java虚拟机都可动态扩展，只不过Java虚拟机规范中也允许固定长度的虚拟机栈），如果扩展时无法申请到足够的内存，就会抛出OutOfMemoryError异常。 —-《深入理解Java虚拟机：JVM高级特性与最佳实践（第2版）》 本地方法栈：和虚拟机栈相似，只不过它服务于Native方法，线程私有。 堆：java内存最大一块，所有对象实例，数组都存放在java堆，GC回收的地方，线程共享。 方法区：存放已被加载类信息、常量、静态变量、即时编译器编译后代码数据等。（即永久化），回收目标主要常量池回收和类型缷载，线程共享。 Java堆溢出Java堆用于存储对象实例，只要不断地创建对象，并且对象数量到达最大堆的容量限制后就会产生内存异常。 代码限制Java堆的大小为20MB，不可扩展（将堆的最小值-Xms参数与最大值-Xmx参数设置为一样即可避免堆自动扩展），通过参数-XX:+HeapDumpOnOutOfMemoryError可以让虚拟机在出现内存溢出异常时Dump出当前的内存堆转储快照以便事后进行分析 1234567891011121314/＊＊ ＊ VM Args：-Xms20m -Xmx20m -XX:+HeapDumpOnOutOfMemoryError ＊ @author zzm ＊/public class HeapOOM &#123; static class OOMObject &#123; &#125; public static void main(String[] args) &#123; List&lt;OOMObject&gt; list = new ArrayList&lt;OOMObject&gt;(); while (true) &#123; list.add(new OOMObject()); &#125; &#125;&#125; 运行结果： 123java.lang.OutOfMemoryError: Java heap spaceDumping heap to java_pid3404.hprof ...Heap dump file created [22045981 bytes in 0.663 secs] 虚拟机桟和本地方法栈溢出 如果线程请求的栈深度大于虚拟机所允许的最大深度，将抛出StackOverflowError异常（方法递归调用） 如果虚拟机在扩展栈时无法申请到足够的内存空间，则抛出OutOfMemoryError异常。（线程过多） 参数 -Xss 去调整JVM栈大小 方法区和运行时常量池溢出由于运行时常量池是方法区的一部分，因此这两个区域的溢出测试就放在一起进行。 String.intern()是一个Native方法，它的作用是：如果字符串常量池中已经包含一个等于此String对象的字符串，则返回代表池中这个字符串的String对象；否则，将此String对象包含的字符串添加到常量池中，并且返回此String对象的引用。 在JDK 1.6及之前的版本中，由于常量池分配在永久代内，我们可以通过-XX:PermSize和-XX:MaxPermSize限制方法区大小。 123456789101112131415/＊＊ ＊ VM Args：-XX:PermSize=10M -XX:MaxPermSize=10M ＊ @author zzm ＊/public class RuntimeConstantPoolOOM &#123; public static void main(String[] args) &#123; //使用List保持着常量池引用，避免Full GC回收常量池行为 List&lt;String&gt; list = new ArrayList&lt;String&gt;(); //10MB的PermSize在integer范围内足够产生OOM了 int i = 0; while (true) &#123; list.add(String.valueOf(i++).intern()); &#125; &#125;&#125; 运行结果： 123Exception in thread &quot;main&quot; java.lang.OutOfMemoryError: PermGen space at java.lang.String.intern(Native Method) at org.fenixsoft.oom.RuntimeConstantPoolOOM.main(RuntimeConstantPoolOOM.java:18)","categories":[{"name":"JVM","slug":"JVM","permalink":"http://example.com/categories/JVM/"}],"tags":[{"name":"java,jvm","slug":"java-jvm","permalink":"http://example.com/tags/java-jvm/"}]},{"title":"你在","slug":"诗词/你在","date":"2023-04-12T16:00:00.000Z","updated":"2023-04-17T15:39:01.412Z","comments":true,"path":"2023/04/13/诗词/你在/","link":"","permalink":"http://example.com/2023/04/13/%E8%AF%97%E8%AF%8D/%E4%BD%A0%E5%9C%A8/","excerpt":"你在 这世界就谈不上好坏","text":"你在 这世界就谈不上好坏 一切的美好都拥你入怀 青山不改 四季繁华 你在 整座城市都眉笑眼开 所有的鲜花都一一盛开 春意盎然 星辰大海 你喜欢将玄之又玄的爱讲给精灵山怪 而万事万物都因为你可爱了起来","categories":[{"name":"诗词","slug":"诗词","permalink":"http://example.com/categories/%E8%AF%97%E8%AF%8D/"}],"tags":[{"name":"现代诗","slug":"现代诗","permalink":"http://example.com/tags/%E7%8E%B0%E4%BB%A3%E8%AF%97/"}]},{"title":"加班","slug":"诗词/加班","date":"2023-04-12T16:00:00.000Z","updated":"2023-04-13T13:07:29.036Z","comments":true,"path":"2023/04/13/诗词/加班/","link":"","permalink":"http://example.com/2023/04/13/%E8%AF%97%E8%AF%8D/%E5%8A%A0%E7%8F%AD/","excerpt":"加班 身体像被什么封印住了 一张桌子、一台电脑、一具行尸走肉","text":"加班 身体像被什么封印住了 一张桌子、一台电脑、一具行尸走肉 青春被打印成了封条贴在工资卡的一栏 每晚七点 等着月亮认领 在沙滩、酒馆、卡拉OK放风 尽情恋爱、喝酒、纵情高歌 而那些更听话的人 留下来加班","categories":[{"name":"诗词","slug":"诗词","permalink":"http://example.com/categories/%E8%AF%97%E8%AF%8D/"}],"tags":[{"name":"现代诗","slug":"现代诗","permalink":"http://example.com/tags/%E7%8E%B0%E4%BB%A3%E8%AF%97/"}]},{"title":"把生活写成诗","slug":"诗词/把生活写成诗","date":"2023-04-12T16:00:00.000Z","updated":"2023-04-17T15:41:15.996Z","comments":true,"path":"2023/04/13/诗词/把生活写成诗/","link":"","permalink":"http://example.com/2023/04/13/%E8%AF%97%E8%AF%8D/%E6%8A%8A%E7%94%9F%E6%B4%BB%E5%86%99%E6%88%90%E8%AF%97/","excerpt":"保温杯再滚烫的热情也会有冷却的时候","text":"保温杯再滚烫的热情也会有冷却的时候 甚至冰凉也许我并不善变毕竟我并不能能插电 红灯车水马龙的大城市站在路口心中有红灯的人怎么走都感觉是在闯红灯 加班身体像被什么封印住了一张桌子、一台电脑、一具行尸走肉青春被打印成了封条贴在工资卡的一栏每晚七点等着月亮认领在沙滩、酒馆、卡拉OK放风尽情恋爱、喝酒、纵情高歌而那些更听话的人留下来加班","categories":[{"name":"诗词","slug":"诗词","permalink":"http://example.com/categories/%E8%AF%97%E8%AF%8D/"}],"tags":[{"name":"现代诗","slug":"现代诗","permalink":"http://example.com/tags/%E7%8E%B0%E4%BB%A3%E8%AF%97/"}]},{"title":"盘点爱情公寓经典语录","slug":"语录/盘点爱情公寓经典语录","date":"2022-10-08T16:00:00.000Z","updated":"2022-10-09T15:32:52.628Z","comments":true,"path":"2022/10/09/语录/盘点爱情公寓经典语录/","link":"","permalink":"http://example.com/2022/10/09/%E8%AF%AD%E5%BD%95/%E7%9B%98%E7%82%B9%E7%88%B1%E6%83%85%E5%85%AC%E5%AF%93%E7%BB%8F%E5%85%B8%E8%AF%AD%E5%BD%95/","excerpt":"如果你知道你的价值，你就前进实现你的价值。","text":"如果你知道你的价值，你就前进实现你的价值。 你们也知道，我只是个小白领，昨天领了工资，交了房屋水电，买了油米泡面，今天发现，这个月的工资又白领了。–李佳航-张伟 行人不能输在斑马线上，孩子不能输在起跑线上，学生不能输在分数线上，村姑不能输在针线上，女人不能输在曲线上，男人不能输在事业线上。–唐悠悠&amp;关谷神奇 生活，就是生出来，活下去。– 孙艺洲-吕子乔 踩到香蕉皮滑倒了，就一定要爬起来，继续踩，踩烂了就不滑了嘛。–曾小贤-陈赫 在皇宫里找工作和现在是一样的，男人要自断命根，女人要卖身求荣。–关谷神奇-王传君 其实我是天才，可惜天妒英才。–李佳航-张伟 当上天无情地关上一扇门，说不定他会在哪里位你打开一扇窗。–类艺潇-胡一菲 只知道说钱的人最终无钱可数。–李金铭-陈美嘉 我以为我是上帝，可以安顿我自己，还可以普渡众生，可是到头来，却是一场空。我没有帮你们实现愿望，对不起，我不是上帝，是寂寞。–陈赫-曾小贤 听闻爱情，十有九伤？ 感情它来的时候，哗啦啦，它就来！感情走的时候，吡溜就走了！ – 孙艺洲-吕子乔 爱情就像牢笼，减刑的唯一方式就是手放开。–类艺潇-胡一菲 小康只是及格水平，尔康才是现在女孩的追求，否则她们会怪你，你不能让她们和她们的孩子，姓福。–李佳航-张伟 爱情并不能解决所有问题！–赵海棠-张一铎 只顾笑了，现在发现全是生活。 你的大脑欺骗了你。你想得太多，所以不知道怎么甩掉劳拉;你想得太多，不知道如何去面对一菲。所以你在不该走的时候走了，不该回来的时候又回来了。– 孙艺洲-吕子乔 有人说幸福就是痒的时候挠一下，不幸就是“痒了但挠不着”。–曾小贤-陈赫 这年头，找个唐僧长相悟空身材沙僧脾气的男朋友不容易，你从了他吧。–类艺潇-胡一菲 许多年后，我还会像现在这样，年复一年，日复一日，做着毫无意义的工作。–李佳航-张伟 怀念以前，珍惜现在。 你说，以前电视剧里插播广告，广告一出来，观众全部上洗手间了，现在倒好了，广告里面插播电视剧，片头曲一出来，观众全去厕所了–陈赫-曾小贤 收钱时什么手续都不用，付钱时手续就比较繁琐，你懂的。–榕榕-LISA榕 现在演戏的都去唱歌了，唱不了歌的都去写书了，写不了书的都去演戏了，演不了戏的又去唱歌了，演艺圈就是个圈嘛。–类艺潇-胡一菲 专家说不会涨价，涨价了。专家说不会地震，地震了。你已经离做专家不远了。–曾小贤-陈赫 这年头，影评都比电影好看！！！！–类艺潇-胡一菲 到了我这个年纪你就知道愿意在你耳边唱歌，喜欢你的肉体，没事送你包包的只有蚊子了。–李佳航-张伟 人与人之间总有分歧，谈恋爱嘛，就是求同存异的过程。不求同嘛，走不到一起，不求异嘛，走不下去。–苑琼丹-苑春丽 活在当下，记住，意外永远比明天来得更快，生活就像一场游戏，你不去刷怪，就被别人刷光了。– 孙艺洲-吕子乔 如果！是回顾分歧的托词！–金世佳-陆展博 天底下最虐心的事儿，就是开家长会的时候，未来的丈母娘就坐你对面，你却只能喊一声，阿姨。–榕榕-LISA榕","categories":[{"name":"经典语录","slug":"经典语录","permalink":"http://example.com/categories/%E7%BB%8F%E5%85%B8%E8%AF%AD%E5%BD%95/"}],"tags":[{"name":"语录","slug":"语录","permalink":"http://example.com/tags/%E8%AF%AD%E5%BD%95/"}]},{"title":"孤独的吉他","slug":"诗词/孤独的吉他","date":"2022-10-08T09:49:00.000Z","updated":"2022-10-08T09:50:32.649Z","comments":true,"path":"2022/10/08/诗词/孤独的吉他/","link":"","permalink":"http://example.com/2022/10/08/%E8%AF%97%E8%AF%8D/%E5%AD%A4%E7%8B%AC%E7%9A%84%E5%90%89%E4%BB%96/","excerpt":"我有一把吉他孤独躺在我的衣柜中有着淡淡的惆怅仅凭着它身上的灰尘辨别出它所留下岁月的痕迹","text":"我有一把吉他孤独躺在我的衣柜中有着淡淡的惆怅仅凭着它身上的灰尘辨别出它所留下岁月的痕迹 我希望有一个拥有俊朗的微笑纤细的指尖长长的发这么一个少年朗重新轻抚它 轻弹一首悲伤的熟悉的老情歌在竹林中轻轻的回荡 擦净弦上的灰尘我才发现调音器都拉不回了动听的音符因此我才如此眷念那个唱老情歌的老朋友","categories":[{"name":"诗词","slug":"诗词","permalink":"http://example.com/categories/%E8%AF%97%E8%AF%8D/"}],"tags":[{"name":"现代诗","slug":"现代诗","permalink":"http://example.com/tags/%E7%8E%B0%E4%BB%A3%E8%AF%97/"}]},{"title":"知否","slug":"诗词/知否","date":"2022-10-08T09:48:00.000Z","updated":"2022-10-08T09:49:03.320Z","comments":true,"path":"2022/10/08/诗词/知否/","link":"","permalink":"http://example.com/2022/10/08/%E8%AF%97%E8%AF%8D/%E7%9F%A5%E5%90%A6/","excerpt":"我将相思种成红豆掬烂如泥的䁔意入喉碗中倒映出的镜片满是回忆相隔一方的故人知否","text":"我将相思种成红豆掬烂如泥的䁔意入喉碗中倒映出的镜片满是回忆相隔一方的故人知否 我满绪的离愁填满明月落花飞尽春无影细雨微风将我唤醒遥远小镇的姑娘知否 我束起灿烂的花枝倾落梦里的眼泪缄在幽暗中的话语终日灌溉蔷薇的美人知否 我推出河心的船㨪荡天上的明月迷惘星夜锁起我的重愁站在窗外写诗的你知否","categories":[{"name":"诗词","slug":"诗词","permalink":"http://example.com/categories/%E8%AF%97%E8%AF%8D/"}],"tags":[{"name":"现代诗","slug":"现代诗","permalink":"http://example.com/tags/%E7%8E%B0%E4%BB%A3%E8%AF%97/"}]},{"title":"老屋","slug":"诗词/老屋","date":"2022-10-08T09:35:00.000Z","updated":"2022-10-08T09:35:46.007Z","comments":true,"path":"2022/10/08/诗词/老屋/","link":"","permalink":"http://example.com/2022/10/08/%E8%AF%97%E8%AF%8D/%E8%80%81%E5%B1%8B/","excerpt":"老屋 由爹娘守候着 和几只母鸡为伴","text":"老屋 由爹娘守候着 和几只母鸡为伴 老屋 在翠竹下依存 与青草相依 老屋 由儿时熟悉的一草一木 变成互不相识 子女远居南北 除了电话问候 间或团聚 我虽与老屋亲密无间 尚存一丝陌生 和老家的天气一样 有点寒冷 何时才能 将老屋纳入自己的心 何时才能与 老屋融合在一起","categories":[{"name":"诗词","slug":"诗词","permalink":"http://example.com/categories/%E8%AF%97%E8%AF%8D/"}],"tags":[{"name":"现代诗","slug":"现代诗","permalink":"http://example.com/tags/%E7%8E%B0%E4%BB%A3%E8%AF%97/"}]},{"title":"数据结构与算法学习-稀疏数组与队列","slug":"数据结构/数据结构与算法学习-稀疏数组与队列","date":"2022-10-07T16:00:00.000Z","updated":"2022-10-08T09:32:26.724Z","comments":true,"path":"2022/10/08/数据结构/数据结构与算法学习-稀疏数组与队列/","link":"","permalink":"http://example.com/2022/10/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0-%E7%A8%80%E7%96%8F%E6%95%B0%E7%BB%84%E4%B8%8E%E9%98%9F%E5%88%97/","excerpt":"稀疏数组基本介绍： 当一个数组中大部分为0，或者为同一个值的数组时，可以利用稀疏数组来保存该数组。","text":"稀疏数组基本介绍： 当一个数组中大部分为0，或者为同一个值的数组时，可以利用稀疏数组来保存该数组。 稀疏数组的处理方法是： 记录数组一共有几行几列，有多少个不同的值 把具有不同值的元素的行列及值记录在一个小规模的数组中，从而缩小程序的规模 先看一个实际的例子，在五子棋中有存盘退出和续上盘的功能。 分析问题：由棋盘的布局可知，程序在实现棋子位置时是以一个多维数组存储中，未落子的地方标识为0，若此时存盘退出就有很多位置都是为0无意义的数据，这些数据也会占有一定的空间。此时可以利用稀疏数组存储有落子的位置，无落子的位置我们无需记录，这将大大节省程序的存储空间。 举例说明： 应用实例： 使用稀疏数组来保存类似前面的二维数组（棋盘、地图等） 把稀疏数组存盘，并且可以从新恢复原来的二维数组 代码实现： 二维数组转稀疏数组 12345678910111213141516171819202122232425262728293031323334/** * 二维数组转稀疏数组 * @param chessArr * @return */public static int[][] twoArrayToSparseArray(int[][] chessArr)&#123; //1、遍历原来的二维数组，得到有效数据的个数sum int sum=0; for (int i=0;i&lt;chessArr.length;i++)&#123; for (int j=0;j&lt;chessArr[i].length;j++)&#123; if (chessArr[i][j] !=0)&#123; sum++; &#125; &#125; &#125; //2、根据sum就可以创建稀疏数组sparseArr int[sum+1][3] int[][] sparseArr = new int[sum+1][3]; sparseArr[0][0] = chessArr.length; sparseArr[0][1] = chessArr[0].length; sparseArr[0][2] = sum; //3、将二维数组的有效数据存入到稀疏数组 int index=1; for (int i=0;i&lt;chessArr.length;i++)&#123; for (int j=0;j&lt;chessArr[i].length;j++)&#123; if (chessArr[i][j] !=0)&#123; sparseArr[index][0]=i; sparseArr[index][1]=j; sparseArr[index][2]=chessArr[i][j]; index++; &#125; &#125; &#125; return sparseArr;&#125; 稀疏数组转二维数组 12345678910111213/** * 稀疏数组转二维数组 * @param sparseArr * @return */public static int[][] sparseArrayToToArray(int[][] sparseArr)&#123; //1、先读取稀疏数组的第一行，根据第一行创建原始的二维数组 int[][] twoArray = new int[sparseArr[0][0]][sparseArr[0][1]]; //2、在读取疏稀数组后几行的数据并赋值给原始的二维数组即可 IntStream.range(1, sparseArr.length) .forEach(i -&gt; twoArray[sparseArr[i][0]][sparseArr[i][1]] = sparseArr[i][2]); return twoArray;&#125; 队列队列介绍 队列是一个有序列表，可以用数组或链表来实现 遵循先入先出的原则：即：先存入队列的数据，要先取出。后存入的要后取出。 示意图：（使用数组模拟队列示意图） 数组模拟队列 队列本身是有序列表，若使用数组的结构来存储队列的数据，则队列数组的声明如下图，其中maxSize是该队列的最大容量。 因为队列的输出、输入是分别从前后端来处理，因此需要两个变量front及rear分别记录队列前后端的下标，front会随着数据输出而改变，而rear则是随着数据的输入而改变，如图所示。 思路分析： 当我们将数据存入队列时称为“addQueue”，addQueue的处理需要有两个步骤： 将尾指针往后移：rear+1，当front&#x3D;&#x3D;rear【空】 若尾指针rear小于队列的最大下标maxSize-1，则将数据存入rear所指的数组元素中，否则无法存入数据。rear&#x3D;&#x3D;maxSize-1【队列满】 代码实现 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586public class ArrayQueue &#123; private Integer front; private Integer rear; private Integer maxSize; int[] arr; /** * 初始化队列 * @param maxSize */ public ArrayQueue(Integer maxSize) &#123; arr = new int[maxSize]; front = -1; rear = -1; this.maxSize = maxSize; &#125; /** * 入队列 * @param sum */ public void popQueue(Integer sum)&#123; rear++; if (rear&gt;=maxSize)&#123; throw new RuntimeException(&quot;超出队列最大长度&quot;); &#125; arr[rear] = sum; &#125; /** * 出队列 * @return */ public void pushQueue()&#123; if (front&gt;=maxSize)&#123; throw new RuntimeException(&quot;超出队列最大长度&quot;); &#125; front++; if (Objects.equals(front,maxSize-1))&#123; front = -1; rear = -1; &#125; &#125; /** * 显示队列的情况 */ public void showQueue()&#123; for (int i=front+1;i&lt;=rear;i++)&#123; System.out.print(arr[i]+&quot; &quot;); &#125; System.out.println(); &#125; public Integer getFront() &#123; return front; &#125; public ArrayQueue setFront(Integer front) &#123; this.front = front; return this; &#125; public Integer getRear() &#123; return rear; &#125; public ArrayQueue setRear(Integer rear) &#123; this.rear = rear; return this; &#125; public Integer getMaxSize() &#123; return maxSize; &#125; public ArrayQueue setMaxSize(Integer maxSize) &#123; this.maxSize = maxSize; return this; &#125;&#125;","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"索引的概述","slug":"Mysql/一、索引的概述","date":"2022-10-02T16:00:00.000Z","updated":"2023-04-13T13:16:23.710Z","comments":true,"path":"2022/10/03/Mysql/一、索引的概述/","link":"","permalink":"http://example.com/2022/10/03/Mysql/%E4%B8%80%E3%80%81%E7%B4%A2%E5%BC%95%E7%9A%84%E6%A6%82%E8%BF%B0/","excerpt":"一、索引的概述1、为什么要使用索引在海量数据中进行查询某条记录的场㬌是时常发生的，那么如何提升查询性能，就跟查询的字段是否有索引有关系。如果字段加了索引，那么查询性能就非常快。","text":"一、索引的概述1、为什么要使用索引在海量数据中进行查询某条记录的场㬌是时常发生的，那么如何提升查询性能，就跟查询的字段是否有索引有关系。如果字段加了索引，那么查询性能就非常快。 索引为什么快？ 索引是什么？ 在使用索引时要注意什么事项？ 2、索引是什么查字典的方式？“数”–通过目录来查，能快速定位到有查找的位置。 没有使用索引时就会进行全表扫描，进行了多次的IO读写，这样的性能较差。 为数据库某个字段创建索引，相当于是为了这个字段的内容创建了一个目录。通过这个目录可以快速实现数据的定位，也就是通过索引能够快速的找到某条数据在磁盘的位置。 3、索引存放的位置对于max系统在&#x2F;user&#x2F;local&#x2F;mysql文件夹中，对于win系统是放在c:&#x2F;programdata&#x2F;mysql（隐藏文件夹） InnoDB存储引擎的表：将索引和数据存放在同一个文件夹李。 MyISAM存储引擎的表：索引和数据分开两个文件夹存储。 4、索引的分类 主键索引：主键自带索引效果，通过主键查询数据性能非常好 普通索引：为普通列创建索引 唯一索引：列中的数据是唯一的，比普通索引的性能有好。 联合索引（组合索引）：一次性为表中的多个字段一起创建索引，最左前缀法则（如何命中联合索引中的索引列）。注意：一个联合索引建议不要超过5个列。 全文索引：MyISAM存储引擎支持全文索引，在实际生产环境中并不会使用MyISAM存储引擎的全文索引来实现全文查找。（为什么不使用？）比如去百度査询数据，来自于网页的标题或网页的内容。 二、索引的数据结构使用索引查找数据性能很快，避免了全表扫描的多次磁盘IO读写，但是我们发现，使用索引实际上也需要在索引中查找数据，而且数据量是一样的，那么凭什么索引就能快呢？这就跟索引使用了哪种数据结构支持快速查找。","categories":[{"name":"Mysql","slug":"Mysql","permalink":"http://example.com/categories/Mysql/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"http://example.com/tags/mysql/"}]},{"title":"她一点头","slug":"诗词/她一点头","date":"2022-10-02T16:00:00.000Z","updated":"2022-10-05T15:33:58.877Z","comments":true,"path":"2022/10/03/诗词/她一点头/","link":"","permalink":"http://example.com/2022/10/03/%E8%AF%97%E8%AF%8D/%E5%A5%B9%E4%B8%80%E7%82%B9%E5%A4%B4/","excerpt":"初夏的阳光正烈 她一点头 散尽树叶的热气，送来一阵凉风的清幽 如一杯蔷薇酒，倾进我的咽喉","text":"初夏的阳光正烈 她一点头 散尽树叶的热气，送来一阵凉风的清幽 如一杯蔷薇酒，倾进我的咽喉 初夏的阳光正烈 她一点头 惊起湖上的青鱼，浮着一阵淋漓的微波 如茉莉的芳秀，载去我的烦愁 初夏的阳光正烈 她一点头 疑集了天上的阴云，遮住一阵似火的皎阳 如古木的象舟，驶入我的心头","categories":[{"name":"诗词","slug":"诗词","permalink":"http://example.com/categories/%E8%AF%97%E8%AF%8D/"}],"tags":[{"name":"现代诗","slug":"现代诗","permalink":"http://example.com/tags/%E7%8E%B0%E4%BB%A3%E8%AF%97/"}]},{"title":"烟花","slug":"诗词/烟花","date":"2022-10-02T16:00:00.000Z","updated":"2022-10-05T15:02:43.272Z","comments":true,"path":"2022/10/03/诗词/烟花/","link":"","permalink":"http://example.com/2022/10/03/%E8%AF%97%E8%AF%8D/%E7%83%9F%E8%8A%B1/","excerpt":"写于2021新年初一晚，感叹新的一年，期待新的希望。","text":"写于2021新年初一晚，感叹新的一年，期待新的希望。 烟花 炮竹好惊眠， 烟花破四天。 穹隆才得显， 今昔换新年。","categories":[{"name":"诗词","slug":"诗词","permalink":"http://example.com/categories/%E8%AF%97%E8%AF%8D/"}],"tags":[{"name":"五言绝句","slug":"五言绝句","permalink":"http://example.com/tags/%E4%BA%94%E8%A8%80%E7%BB%9D%E5%8F%A5/"}]},{"title":"爱情中的抬头与低头","slug":"诗词/爱情中的抬头与低头","date":"2022-10-02T16:00:00.000Z","updated":"2022-10-05T15:27:04.863Z","comments":true,"path":"2022/10/03/诗词/爱情中的抬头与低头/","link":"","permalink":"http://example.com/2022/10/03/%E8%AF%97%E8%AF%8D/%E7%88%B1%E6%83%85%E4%B8%AD%E7%9A%84%E6%8A%AC%E5%A4%B4%E4%B8%8E%E4%BD%8E%E5%A4%B4/","excerpt":"我深信相爱的人， 每次言语不和的转身 都会碰头","text":"我深信相爱的人， 每次言语不和的转身 都会碰头 我深信相爱的人 每次无奈的分离 都会相遇 如若看着对方远走 都会情不自禁地低头 下一刻相遇 都会若无其事地环顾左右","categories":[{"name":"诗词","slug":"诗词","permalink":"http://example.com/categories/%E8%AF%97%E8%AF%8D/"}],"tags":[{"name":"现代诗","slug":"现代诗","permalink":"http://example.com/tags/%E7%8E%B0%E4%BB%A3%E8%AF%97/"}]},{"title":"绯红的书签","slug":"诗词/绯红的书签","date":"2022-10-02T14:18:01.000Z","updated":"2022-10-02T14:29:35.314Z","comments":true,"path":"2022/10/02/诗词/绯红的书签/","link":"","permalink":"http://example.com/2022/10/02/%E8%AF%97%E8%AF%8D/%E7%BB%AF%E7%BA%A2%E7%9A%84%E4%B9%A6%E7%AD%BE/","excerpt":"我喜欢秋天，更喜欢绯红色","text":"我喜欢秋天，更喜欢绯红色 绯红的枫叶落到泥土中 带着绝望和消逝的一切死去 阳光带走了它的生命与灵魂 失去了树根的滋养和阳光的照射 它成了枯萎的残花 没人记得它曾多么艳丽 多么令人高不可攀 行人在树下欣赏着树上的鲜花 而它只是泥土上不起眼的存在 它伤心难过 随着风离开了这个伤心地 一直飘了很远很远 直到落到我的窗前成了我的书签 我小心翼翼将它夹在笔记本中 赋予了它新的生命","categories":[{"name":"诗词","slug":"诗词","permalink":"http://example.com/categories/%E8%AF%97%E8%AF%8D/"}],"tags":[{"name":"现代词","slug":"现代词","permalink":"http://example.com/tags/%E7%8E%B0%E4%BB%A3%E8%AF%8D/"}]},{"title":"写给我逝去的猫","slug":"诗词/写给我逝去的猫","date":"2022-10-02T14:18:00.000Z","updated":"2022-10-05T15:02:48.665Z","comments":true,"path":"2022/10/02/诗词/写给我逝去的猫/","link":"","permalink":"http://example.com/2022/10/02/%E8%AF%97%E8%AF%8D/%E5%86%99%E7%BB%99%E6%88%91%E9%80%9D%E5%8E%BB%E7%9A%84%E7%8C%AB/","excerpt":"这首诗写给我逝去的猫，希望它换了一个地方依然保持纯真、好奇。","text":"这首诗写给我逝去的猫，希望它换了一个地方依然保持纯真、好奇。 在平静的日子里 揺着转椅转了很久 它躺在我的腿上睡去 是洪水猛兽也抵不过的温柔 它喜欢跳上茶席不断搅局 又主动投怀送抱的那一刻回眸 我起床，它跟着我 我回家的开门声一响 没有谁比它的到来更迅疾的 它心形的俏脸，在昏暗的灯下 陷入一个遥远的悲情故事 我试图以男主角的身份与它携手 而它又会转头故作高冷 我蒙上眼假装哭泣 它会轻轻舔我的手表示和解 它是一只背着苦灵魂的猫 在丛林穿越 疲惫不堪又惶恐不安 然而它不能停 山川、河流、田野 都被它抛到了后面 最终它找到了一个安详之地 永远的离我而去","categories":[{"name":"诗词","slug":"诗词","permalink":"http://example.com/categories/%E8%AF%97%E8%AF%8D/"}],"tags":[{"name":"现代词","slug":"现代词","permalink":"http://example.com/tags/%E7%8E%B0%E4%BB%A3%E8%AF%8D/"}]},{"title":"Mysql基础整理（1）","slug":"Mysql/2022102-Mysql八股文整理（1）","date":"2022-10-01T16:00:00.000Z","updated":"2022-10-02T10:56:28.657Z","comments":true,"path":"2022/10/02/Mysql/2022102-Mysql八股文整理（1）/","link":"","permalink":"http://example.com/2022/10/02/Mysql/2022102-Mysql%E5%85%AB%E8%82%A1%E6%96%87%E6%95%B4%E7%90%86%EF%BC%881%EF%BC%89/","excerpt":"Mysql是面试中常问的知识点，也是我们在工作中最常使用的技能之一，因此不管是面试还是工作，对于Mysql的基础掌握都是很有必要的。从这一篇开始我将不定期整理关于Mysql面试中常问到的知识点，以便在以后工作或面试中能展现良好的基础能力。","text":"Mysql是面试中常问的知识点，也是我们在工作中最常使用的技能之一，因此不管是面试还是工作，对于Mysql的基础掌握都是很有必要的。从这一篇开始我将不定期整理关于Mysql面试中常问到的知识点，以便在以后工作或面试中能展现良好的基础能力。 1、什么是内连接、外连接、交叉连接、笛卡尔积呢？内连接（inner join）:取得两张表中满足连接匹配关系的记录。 1select 查询字段 from 表1,表2 where 表1.关系字段=表2.关系字段； 外连接（outer join）:不只取得两张表中满足存在连接匹配关系的记录，还包括某张表（或两张表）中不满足匹配关系的记录。 1select..from表1 left join 表2 on 条件(表1:为左表，表2：为右表) 交叉连接（cross join）：显示两张表所有记录一一对应，没有匹配关系筛选，它是笛卡尔积在SQL中的实现，如果A表有m行，B表有n行，那么A和B交叉连接的结果就有m*n行。 1select 查询内容 from 表1 cross join 表2 笛卡尔积：是数学中的一个概念，例如集合A&#x3D;{a,b}，集合B&#x3D;{1,2,3}，那么AXB&#x3D;{&lt;a,0&gt;,&lt;a,1&gt;,&lt;a,2&gt;,&lt;b,0&gt;,&lt;b,1&gt;,&lt;b,2&gt;}。 2、Mysql的内连接、左连接、右连接有什么区别？MySQL的连接主要分为内连接和外连接，外连接常用的有左连接、右连接。 inner join 内连接，在两张表进行连接查询时，只保留两张表中完全匹配的结果 集 left join 在两张表进行连接查询时，会返回左表所有的行，即使在右表中没有匹 配的记录。 right join 在两张表进行连接查询时，会返回右表所有的行，即使在左表中没有匹 配的记录。 3、数据库的三大范式 第一范式：数据表中的每一列（每个字段）都不可以再拆分。 例如用户表，用户地址还可以拆分成国家、省份、市，这样才是符合第一范式 的。 第二范式：在第一范式的基础上，非主键列完全依赖于主键，而不能是依赖于主 键的一部分。 例如订单表里，存储了商品信息（商品价格、商品类型），那就需要把商品ID 和订单ID作为联合主键，才满足第二范式。 第二范式：在第一范式的基础上，非主键列完全依赖于主键，而不能是依赖于主 键的一部分。 例如订单表里，存储了商品信息（商品价格、商品类型），那就需要把商品ID 和订单ID作为联合主键，才满足第二范式。 三大范式的作用是为了控制数据库的冗余，是对空间的节省，实际上，一般互联网 公司的设计都是反范式的，通过冗余一些数据，避免跨表跨库，利用空间换时间， 提高性能。 4、varcher与char的区别 char： char表示定长字符串，长度是固定的； 如果插入数据的长度小于char的固定长度时，则用空格填充； 因为长度固定因此char的存取速度要比varchar快，甚至能快50%，但因为其长度固定往往能浪费一些空间，是用空间换时间的做法。 对于char来说，最多能存放的字符个数为255，和编码无关 varchar： varchar表示可变长字符串，长度是可变的； varchar表示可变长字符串，长度是可变的； varchar在存取方面与char相反，它存取慢，因为长度不固定，但正因如此，不占 据多余的空间，是时间换空间的做法； 对于varchar来说，最多能存放的字符个数为65532 日常的设计，对于长度相对固定的字符串，可以使用char，对于长度不确定的，使用 varchar更合适一些。 5、blob和text有什么区别 blob用于存储二进制数据，而text用于存储大字符串。 blob没有字符集，text有一个字符集，并且根据字符集的校对规则对值进行排序 和比较","categories":[{"name":"Mysql","slug":"Mysql","permalink":"http://example.com/categories/Mysql/"}],"tags":[{"name":"Mysql","slug":"Mysql","permalink":"http://example.com/tags/Mysql/"}]},{"title":"SpringBoot 实现接口参数加密解密功能","slug":"SpringBoot/SpringBoot-实现接口参数加密解密功能","date":"2022-10-01T16:00:00.000Z","updated":"2022-10-02T09:54:40.717Z","comments":true,"path":"2022/10/02/SpringBoot/SpringBoot-实现接口参数加密解密功能/","link":"","permalink":"http://example.com/2022/10/02/SpringBoot/SpringBoot-%E5%AE%9E%E7%8E%B0%E6%8E%A5%E5%8F%A3%E5%8F%82%E6%95%B0%E5%8A%A0%E5%AF%86%E8%A7%A3%E5%AF%86%E5%8A%9F%E8%83%BD/","excerpt":"加密解密本身并不是难事，问题是在何时去处理？定义一个过滤器，将请求和响应分别拦截下来进行处理也是一个办法，这种方式虽然粗暴，但是灵活，因为可以拿到一手的请求参数和响应数据。不过 SpringMVC 中给我们提供了 ResponseBodyAdvice 和 RequestBodyAdvice，利用这两个工具可以对请求和响应进行预处理，非常方便","text":"加密解密本身并不是难事，问题是在何时去处理？定义一个过滤器，将请求和响应分别拦截下来进行处理也是一个办法，这种方式虽然粗暴，但是灵活，因为可以拿到一手的请求参数和响应数据。不过 SpringMVC 中给我们提供了 ResponseBodyAdvice 和 RequestBodyAdvice，利用这两个工具可以对请求和响应进行预处理，非常方便 所以今天这篇文章有两个目的： 分享参数&#x2F;响应加解密的思路。 分享 ResponseBodyAdvice 和 RequestBodyAdvice 的用法。 好了，那么接下来就不废话了，我们一起来看下。 开发加解密 starter为了让我们开发的这个工具更加通用，也为了复习一下自定义 Spring Boot Starter，这里我们就将这个工具做成一个 stater，以后在 Spring Boot 项目中直接引用就可以。 1.1 创建项目首先我们创建一个 Spring Boot 项目，引入 spring-boot-starter-web 依赖： 123456&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;version&gt;2.4.3&lt;/version&gt;&lt;/dependency&gt; 因为我们这个工具是为 Web 项目开发的，以后必然使用在 Web 环境中，所以这里添加依赖时 scope 设置为 provided。 1.2 加密工具类依赖添加完成后，我们先来定义一个加密工具类备用，加密这块有多种方案可以选择，对称加密、非对称加密，其中对称加密又可以使用 AES、DES、3DES 等不同算法，这里我们使用 Java 自带的 Cipher 来实现对称加密，使用 AES 算法： 123456789101112131415161718192021222324public class AESUtils &#123; private static final String AES_ALGORITHM = &quot;AES/ECB/PKCS5Padding&quot;; // 获取 cipher private static Cipher getCipher(byte[] key, int model) throws Exception &#123; SecretKeySpec secretKeySpec = new SecretKeySpec(key, &quot;AES&quot;); Cipher cipher = Cipher.getInstance(AES_ALGORITHM); cipher.init(model, secretKeySpec); return cipher; &#125; // AES加密 public static String encrypt(byte[] data, byte[] key) throws Exception &#123; Cipher cipher = getCipher(key, Cipher.ENCRYPT_MODE); return Base64.getEncoder().encodeToString(cipher.doFinal(data)); &#125; // AES解密 public static byte[] decrypt(byte[] data, byte[] key) throws Exception &#123; Cipher cipher = getCipher(key, Cipher.DECRYPT_MODE); return cipher.doFinal(Base64.getDecoder().decode(data)); &#125;&#125; 这个工具类比较简单，不需要多解释。需要说明的是，加密后的数据可能不具备可读性，因此我们一般需要对加密后的数据再使用 Base64 算法进行编码，获取可读字符串。换言之，上面的 AES 加密方法的返回值是一个 Base64 编码之后的字符串，AES 解密方法的参数也是一个 Base64 编码之后的字符串，先对该字符串进行解码，然后再解密。 1.3 响应工具类接下来我们封装一个响应工具类备用： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061public class RespBean &#123; private Integer status; private String msg; private Object obj; public static RespBean build() &#123; return new RespBean(); &#125; public static RespBean ok(String msg) &#123; return new RespBean(200, msg, null); &#125; public static RespBean ok(String msg, Object obj) &#123; return new RespBean(200, msg, obj); &#125; public static RespBean error(String msg) &#123; return new RespBean(500, msg, null); &#125; public static RespBean error(String msg, Object obj) &#123; return new RespBean(500, msg, obj); &#125; private RespBean() &#123; &#125; private RespBean(Integer status, String msg, Object obj) &#123; this.status = status; this.msg = msg; this.obj = obj; &#125; public Integer getStatus() &#123; return status; &#125; public RespBean setStatus(Integer status) &#123; this.status = status; return this; &#125; public String getMsg() &#123; return msg; &#125; public RespBean setMsg(String msg) &#123; this.msg = msg; return this; &#125; public Object getObj() &#123; return obj; &#125; public RespBean setObj(Object obj) &#123; this.obj = obj; return this; &#125;&#125; 1.4 定义注解接下来我们定义两个注解 @Decrypt 和 @Encrypt： 12345678@Retention(RetentionPolicy.RUNTIME)@Target(&#123;ElementType.METHOD,ElementType.PARAMETER&#125;)public @interface Decrypt &#123;&#125;@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.METHOD)public @interface Encrypt &#123;&#125; 这两个注解就是两个标记，在以后使用的过程中，哪个接口方法添加了 @Encrypt 注解就对哪个接口的数据加密返回，哪个接口&#x2F;参数添加了 @Decrypt 注解就对哪个接口&#x2F;参数进行解密。这个定义也比较简单，没啥好说的，需要注意的是 @Decrypt比 @Encrypt 多了一个使用场景就是 @Decrypt 可以用在参数上。 1.5 定义一个 EncryptProperties 类来读取用户配置的 key考虑到用户可能会自己配置加密的 key，因此我们再来定义一个 EncryptProperties 类来读取用户配置的 key： 12345678910111213@ConfigurationProperties(prefix = &quot;spring.encrypt&quot;)public class EncryptProperties &#123; private final static String DEFAULT_KEY = &quot;www.itboyhub.com&quot;; private String key = DEFAULT_KEY; public String getKey() &#123; return key; &#125; public void setKey(String key) &#123; this.key = key; &#125;&#125; 这里我设置了默认的 key 是 www.itboyhub.com，key 是 16 位字符串，这个网站地址刚好满足。以后如果用户想自己配置 key，只需要在 application.properties 中配置 spring.encrypt.key=xxx 即可。 所有准备工作做完了，接下来就该正式加解密了。 因为这篇文章一个很重要的目的是想和大家分享 ResponseBodyAdvice 和 RequestBodyAdvice 的用法，RequestBodyAdvice 在做解密的时候倒是没啥问题，而 ResponseBodyAdvice 在做加密的时候则会有一些局限，不过影响不大，还是我前面说的，如果想非常灵活的掌控一切，那还是自定义过滤器吧。这里我就先用这两个工具来实现了。 另外还有一点需要注意，ResponseBodyAdvice 在你使用了 @ResponseBody 注解的时候才会生效，RequestBodyAdvice 在你使用了 @RequestBody 注解的时候才会生效，换言之，前后端都是 JSON 交互的时候，这两个才有用。不过一般来说接口加解密的场景也都是前后端分离的时候才可能有的事。 1.6 接口加密先来看接口加密： 123456789101112131415161718192021222324252627@EnableConfigurationProperties(EncryptProperties.class)@ControllerAdvicepublic class EncryptResponse implements ResponseBodyAdvice&lt;RespBean&gt; &#123; private ObjectMapper om = new ObjectMapper(); @Autowired EncryptProperties encryptProperties; @Override public boolean supports(MethodParameter returnType, Class&lt;? extends HttpMessageConverter&lt;?&gt;&gt; converterType) &#123; return returnType.hasMethodAnnotation(Encrypt.class); &#125; @Override public RespBean beforeBodyWrite(RespBean body, MethodParameter returnType, MediaType selectedContentType, Class&lt;? extends HttpMessageConverter&lt;?&gt;&gt; selectedConverterType, ServerHttpRequest request, ServerHttpResponse response) &#123; byte[] keyBytes = encryptProperties.getKey().getBytes(); try &#123; if (body.getMsg()!=null) &#123; body.setMsg(AESUtils.encrypt(body.getMsg().getBytes(),keyBytes)); &#125; if (body.getObj() != null) &#123; body.setObj(AESUtils.encrypt(om.writeValueAsBytes(body.getObj()), keyBytes)); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return body; &#125;&#125; 我们自定义 EncryptResponse 类实现 ResponseBodyAdvice接口，泛型表示接口的返回类型，这里一共要实现两个方法： supports：这个方法用来判断什么样的接口需要加密，参数 returnType 表示返回类型，我们这里的判断逻辑就是方法是否含有 @Encrypt 注解，如果有，表示该接口需要加密处理，如果没有，表示该接口不需要加密处理。 beforeBodyWrite：这个方法会在数据响应之前执行，也就是我们先对响应数据进行二次处理，处理完成后，才会转成 json 返回。我们这里的处理方式很简单，RespBean 中的 status 是状态码就不用加密了，另外两个字段重新加密后重新设置值即可。 另外需要注意，自定义的 ResponseBodyAdvice 需要用 @ControllerAdvice 注解来标记。 1.7 接口解密再来看接口解密： 12345678910111213141516171819202122232425262728293031323334@EnableConfigurationProperties(EncryptProperties.class)@ControllerAdvicepublic class DecryptRequest extends RequestBodyAdviceAdapter &#123; @Autowired EncryptProperties encryptProperties; @Override public boolean supports(MethodParameter methodParameter, Type targetType, Class&lt;? extends HttpMessageConverter&lt;?&gt;&gt; converterType) &#123; return methodParameter.hasMethodAnnotation(Decrypt.class) || methodParameter.hasParameterAnnotation(Decrypt.class); &#125; @Override public HttpInputMessage beforeBodyRead(final HttpInputMessage inputMessage, MethodParameter parameter, Type targetType, Class&lt;? extends HttpMessageConverter&lt;?&gt;&gt; converterType) throws IOException &#123; byte[] body = new byte[inputMessage.getBody().available()]; inputMessage.getBody().read(body); try &#123; byte[] decrypt = AESUtils.decrypt(body, encryptProperties.getKey().getBytes()); final ByteArrayInputStream bais = new ByteArrayInputStream(decrypt); return new HttpInputMessage() &#123; @Override public InputStream getBody() throws IOException &#123; return bais; &#125; @Override public HttpHeaders getHeaders() &#123; return inputMessage.getHeaders(); &#125; &#125;; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return super.beforeBodyRead(inputMessage, parameter, targetType, converterType); &#125;&#125; 首先大家注意，DecryptRequest 类我们没有直接实现 RequestBodyAdvice 接口，而是继承自 RequestBodyAdviceAdapter 类，该类是 RequestBodyAdvice 接口的子类，并且实现了接口中的一些方法，这样当我们继承自 RequestBodyAdviceAdapter 时，就只需要根据自己实际需求实现某几个方法即可。 supports：该方法用来判断哪些接口需要处理接口解密，我们这里的判断逻辑是方法上或者参数上含有 @Decrypt 注解的接口，处理解密问题。 beforeBodyRead：这个方法会在参数转换成具体的对象之前执行，我们先从流中加载到数据，然后对数据进行解密，解密完成后再重新构造 HttpInputMessage 对象返回。 1.8 定义一个自动化配置类接下来，我们再来定义一个自动化配置类，如下： 12345@Configuration@ComponentScan(&quot;org.javaboy.encrypt.starter&quot;)public class EncryptAutoConfiguration &#123;&#125; 这个也没啥好说的，比较简单。 最后，resources 目录下定义 META-INF，然后再定义 spring.factories 文件，内容如下： 1org.springframework.boot.autoconfigure.EnableAutoConfiguration=org.javaboy.encrypt.starter.autoconfig.EncryptAutoConfiguration 这样当项目启动时，就会自动加载该配置类。 至此，我们的 starter 就开发完成啦。 2.打包发布我们可以将项目安装到本地仓库，也可以发布到线上供他人使用。 发不到线上我们可以使用 JitPack 来做。 首先我们在 GitHub 上创建一个仓库，将我们的代码上传上去，这个过程应该不用我多说吧。 上传成功后，点击右边的 Create a new release 按钮，发布一个正式版，如下： 编辑 编辑 发布成功后，打开 jitpack，输入仓库的完整路径，点击 lookup 按钮，查找到之后，再点击 Get it 按钮完成构建，如下： 编辑 构建成功后，JitPack 上会给出项目引用方式： 注意引用时将 tag 改成你具体的版本号。 至此，我们的工具就已经成功发布了！小伙伴们可以通过如下方式引用这个 starter： 12345678910111213&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;com.github.lenve&lt;/groupId&gt; &lt;artifactId&gt;encrypt-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;0.0.3&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt;&lt;repositories&gt; &lt;repository&gt; &lt;id&gt;jitpack.io&lt;/id&gt; &lt;url&gt;https://jitpack.io&lt;/url&gt; &lt;/repository&gt;&lt;/repositories&gt; 3.应用我们创建一个普通的 Spring Boot 项目，引入 web 依赖，再引入我们刚刚的 starter 依赖，如下： 12345678910111213141516171819202122&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.github.lenve&lt;/groupId&gt; &lt;artifactId&gt;encrypt-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;0.0.3&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt;&lt;/dependencies&gt;&lt;repositories&gt; &lt;repository&gt; &lt;id&gt;jitpack.io&lt;/id&gt; &lt;url&gt;https://jitpack.io&lt;/url&gt; &lt;/repository&gt;&lt;/repositories&gt; 然后再创建一个实体类备用： 12345public class User &#123; private Long id; private String username; //省略 getter/setter&#125; 创建两个测试接口： 1234567891011121314151617@RestControllerpublic class HelloController &#123; @GetMapping(&quot;/user&quot;) @Encrypt public RespBean getUser() &#123; User user = new User(); user.setId((long) 99); user.setUsername(&quot;javaboy&quot;); return RespBean.ok(&quot;ok&quot;, user); &#125; @PostMapping(&quot;/user&quot;) public RespBean addUser(@RequestBody @Decrypt User user) &#123; System.out.println(&quot;user = &quot; + user); return RespBean.ok(&quot;ok&quot;, user); &#125;&#125; 第一个接口使用了 @Encrypt 注解，所以会对该接口的数据进行加密（如果不使用该注解就不加密），第二个接口使用了 @Decrypt 所以会对上传的参数进行解密，注意 @Decrypt 注解既可以放在方法上也可以放在参数上。","categories":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://example.com/categories/SpringBoot/"}],"tags":[{"name":"springboot","slug":"springboot","permalink":"http://example.com/tags/springboot/"}]},{"title":"知识体系构建中提示页面","slug":"知识体系构建中提示页面","date":"2020-06-05T16:00:00.000Z","updated":"2023-06-07T14:37:22.633Z","comments":true,"path":"2020/06/06/知识体系构建中提示页面/","link":"","permalink":"http://example.com/2020/06/06/%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E6%9E%84%E5%BB%BA%E4%B8%AD%E6%8F%90%E7%A4%BA%E9%A1%B5%E9%9D%A2/","excerpt":"","text":"该章节还在整理中，敬请期待………","categories":[{"name":"提示","slug":"提示","permalink":"http://example.com/categories/%E6%8F%90%E7%A4%BA/"}],"tags":[{"name":"提示","slug":"提示","permalink":"http://example.com/tags/%E6%8F%90%E7%A4%BA/"}]}],"categories":[{"name":"并发编程","slug":"并发编程","permalink":"http://example.com/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"},{"name":"计划","slug":"计划","permalink":"http://example.com/categories/%E8%AE%A1%E5%88%92/"},{"name":"诗词","slug":"诗词","permalink":"http://example.com/categories/%E8%AF%97%E8%AF%8D/"},{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"JVM","slug":"JVM","permalink":"http://example.com/categories/JVM/"},{"name":"经典语录","slug":"经典语录","permalink":"http://example.com/categories/%E7%BB%8F%E5%85%B8%E8%AF%AD%E5%BD%95/"},{"name":"Mysql","slug":"Mysql","permalink":"http://example.com/categories/Mysql/"},{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://example.com/categories/SpringBoot/"},{"name":"提示","slug":"提示","permalink":"http://example.com/categories/%E6%8F%90%E7%A4%BA/"}],"tags":[{"name":"并发编程","slug":"并发编程","permalink":"http://example.com/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"},{"name":"计划","slug":"计划","permalink":"http://example.com/tags/%E8%AE%A1%E5%88%92/"},{"name":"现代诗","slug":"现代诗","permalink":"http://example.com/tags/%E7%8E%B0%E4%BB%A3%E8%AF%97/"},{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"jvm","slug":"jvm","permalink":"http://example.com/tags/jvm/"},{"name":"java,jvm","slug":"java-jvm","permalink":"http://example.com/tags/java-jvm/"},{"name":"语录","slug":"语录","permalink":"http://example.com/tags/%E8%AF%AD%E5%BD%95/"},{"name":"mysql","slug":"mysql","permalink":"http://example.com/tags/mysql/"},{"name":"五言绝句","slug":"五言绝句","permalink":"http://example.com/tags/%E4%BA%94%E8%A8%80%E7%BB%9D%E5%8F%A5/"},{"name":"现代词","slug":"现代词","permalink":"http://example.com/tags/%E7%8E%B0%E4%BB%A3%E8%AF%8D/"},{"name":"Mysql","slug":"Mysql","permalink":"http://example.com/tags/Mysql/"},{"name":"springboot","slug":"springboot","permalink":"http://example.com/tags/springboot/"},{"name":"提示","slug":"提示","permalink":"http://example.com/tags/%E6%8F%90%E7%A4%BA/"}]}